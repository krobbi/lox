// Lynx
// Lox preprocessor.

// #import <call_main>
// #import <list>

// #import "ast/visitors/emit_tokens_visitor.lox"
// #import "config/config.lox"
// #import "importer/importer.lox"
// #import "log/char.lox"

// Write a message to an output stream.
fun write(message, stream) {
	var length = __strlen(message);
	
	for (var i = 0; i < length; i = i + 1) {
		__fputc(__chrat(message, i), stream);
	}
}

// Write a message to an output stream with a line feed.
fun writeLine(message, stream) {
	write(message, stream);
	__fputc(Char.LF, stream);
}

// Write a program to an output path with a log.
fun writeProgram(program, path, log) {
	var stream = __fopenw(path);
	
	if (!stream) {
		log.logError("Could not open output file '" + path + "'.");
		return;
	}
	
	var tokens = List();
	EmitTokensVisitor(tokens.pushBack).visit(program);
	var width = 0;
	var needsSpace = false;
	
	for (var iter = tokens.iter(); iter.hasNext();) {
		var lexeme = iter.getNext().getLexeme();
		var length = __strlen(lexeme);
		
		if (needsSpace) {
			width = width + 1;
		}
		
		if (width + length > 80) {
			writeLine("", stream);
			width = 0;
			needsSpace = false;
		}
		
		if (needsSpace) {
			write(" ", stream);
		}
		
		write(lexeme, stream);
		width = width + length;
		needsSpace = true;
		
		if (!iter.hasNext()) {
			writeLine("", stream);
		}
	}
	
	if (!__fclose(stream)) {
		log.logError("Could not close output file '" + path + "'.");
	}
}

// Run Lynx from configuration.
fun run(config) {
	var program = Importer(config).importProgram();
	var path = config.getOutputPath();
	var log = config.getLog();
	
	if (!path or log.hasErrors()) {
		return;
	}
	
	writeProgram(program, path, log);
}

// Run Lynx from arguments and return an exit status code.
fun main(args) {
	var config = Config(args);
	var log = config.getLog();
	
	if (log.hasErrors()) {
		log.flush();
		return 1;
	}
	
	run(config);
	
	if (log.hasErrors()) {
		log.flush();
		return 1;
	}
	
	return 0;
}

callMain(main);
