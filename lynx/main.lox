// Lynx
// Lox preprocessor.

// #import <call_main>
// #import <list>

// #import "ast/visitors/emit_tokens_visitor.lox"
// #import "config/config.lox"
// #import "importer/importer.lox"
// #import "log/char.lox"
// #import "token/token_spacing.lox"

// Write a program to an output path with a log.
fun writeProgram(program, path, log) {
	var stream = __fopenw(path);
	
	if (!stream) {
		log.logError("Could not open output file '" + path + "'.");
		return;
	}
	
	var tokens = List();
	EmitTokensVisitor(tokens.pushBack).visit(program);
	var prevSpacing = TokenSpacing.NONE;
	var width = 0;
	
	for (var iter = tokens.iter(); iter.hasNext();) {
		var token = iter.getNext();
		var spacing = token.getSpacing();
		var hasSpace = TokenSpacing.between(prevSpacing, spacing);
		
		if (hasSpace) {
			width = width + 1;
		}
		
		var lexeme = token.getLexeme();
		var length = __strlen(lexeme);
		
		if (width + length > 80) {
			__fputc(Char.LF, stream);
			width = 0;
			hasSpace = false;
		} else if (hasSpace) {
			__fputc(Char.SPACE, stream);
		}
		
		for (var i = 0; i < length; i = i + 1) {
			__fputc(__chrat(lexeme, i), stream);
		}
		
		width = width + length;
		prevSpacing = spacing;
		
		if (!iter.hasNext()) {
			__fputc(Char.LF, stream);
		}
	}
	
	if (!__fclose(stream)) {
		log.logError("Could not close output file '" + path + "'.");
	}
}

// Run Lynx from configuration.
fun run(config) {
	var program = Importer(config).importProgram();
	var path = config.getOutputPath();
	var log = config.getLog();
	
	if (!path or log.hasErrors()) {
		return;
	}
	
	writeProgram(program, path, log);
}

// Run Lynx from arguments and return an exit status code.
fun main(args) {
	var config = Config(args);
	var log = config.getLog();
	
	if (log.hasErrors()) {
		log.flush();
		return 1;
	}
	
	run(config);
	
	if (log.hasErrors()) {
		log.flush();
		return 1;
	}
	
	return 0;
}

callMain(main);
