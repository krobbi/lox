// Imports a program AST from configuration.
class Importer {
	// Initialize the importer from its configuration.
	init(config) {
		var mainPath = config.getMainPath();
		var mainName = "";
		
		{
			var length = __strlen(mainPath);
			var pivot = length - 1;
			
			for (var isLooping = true; isLooping;) {
				var char = __chrat(mainPath, pivot);
				
				if (char == Char.SLASH or char == Char.BACKSLASH) {
					isLooping = false;
				} else {
					pivot = pivot - 1;
					
					if (pivot < 0) {
						isLooping = false;
					}
				}
			}
			
			var path = "";
			
			for (var i = 0; i < length; i = i + 1) {
				var character = __strof(__chrat(mainPath, i));
				
				if (i <= pivot) {
					path = path + character;
				} else {
					mainName = mainName + character;
				}
			}
			
			mainPath = path;
		}
		
		var stdPath = config.getStdPath();
		
		if (stdPath and stdPath != "") {
			var char = __chrat(stdPath, __strlen(stdPath) - 1);
			
			if (char != Char.SLASH and char != Char.BACKSLASH) {
				stdPath = stdPath + "/";
			}
		}
		
		// The importer's configuration.
		this._config = config;
		
		// The importer's log.
		this._log = config.getLog();
		
		// The importer's main path.
		this._mainPath = mainPath;
		
		// The importer's main module name.
		this._mainName = mainName;
		
		// The importer's optional standard library path.
		this._stdPath = stdPath;
		
		// The importer's map of dependency names to dependencies.
		this._dependencies = Map();
	}
	
	// Import a program or log an error.
	importProgram() {
		if (!this._validatePart(this._mainName)) {
			this._log.logError("Main path '" + this._config.getMainPath() + "' is invalid.");
			return nil;
		}
		
		var main = this._getDependency(this._mainName, nil);
		
		if (!main) {
			return nil;
		}
		
		return ProgramNode(this._resolveDependency(main));
	}
	
	// Get a dependency from its name or log an error at a span.
	_getDependency(name, span) {
		var dependency = this._dependencies.get(name);
		
		if (dependency) {
			return dependency;
		}
		
		var path = this._nameToPath(name);
		var stream = __fopenr(path);
		
		if (!stream) {
			this._log.logErrorAt(
					"Could not open source file '" + path + "'. File may not exist.", span);
			return nil;
		}
		
		dependency = Dependency(name, Parser(this._config, name, stream).parseModule());
		this._dependencies.set(name, dependency);
		return dependency;
	}
	
	// Convert a dependency name to a path.
	_nameToPath(name) {
		return this._mainPath + name;
	}
	
	// Get whether a path part is valid.
	_validatePart(part) {
		if (part == "" or __chrat(part, 0) == Char.SPACE) {
			return false;
		}
		
		var length = __strlen(part);
		
		{
			var tail = __chrat(part, length - 1);
			
			if (tail == Char.SPACE or tail == Char.DOT) {
				return false;
			}
		}
		
		var prev = nil;
		
		for (var i = 0; i < length; i = i + 1) {
			var char = __chrat(part, i);
			
			if (
					char < Char.SPACE or char > Char.TILDE
					or char == Char.QUOTE
					or char == Char.STAR
					or char == Char.SLASH
					or char == Char.COLON
					or char == Char.LESS
					or char == Char.GREATER
					or char == Char.QUESTION
					or char == Char.BACKSLASH
					or char == Char.CARET
					or char == Char.PIPE
					or char == prev and (char == Char.SPACE or char == Char.DOT)) {
				return false;
			}
			
			prev = char;
		}
		
		return true;
	}
	
	// Resolve a dependency's modules in topological order.
	_resolveDependency(dependency) {
		return List().pushBack(dependency.getModule());
	}
}
