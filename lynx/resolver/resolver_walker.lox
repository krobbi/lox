// #import <list>

// #import "/ast/walker.lox"
// #import "class_type.lox"
// #import "function_type.lox"
// #import "scope.lox"

// Walks AST nodes and resolves them.
class ResolverWalker < Walker {
	// Initialize the resolver walker from configuration.
	init(config) {
		super.init();
		
		// The resolver walker's log.
		this._log = config.getLog();
		
		// The resolver walker's scope stack.
		this._scopes = List();
	}
	
	// Resolve a program node.
	visitProgram(node) {
		this._beginScope(ClassType.NONE, FunctionType.NONE);
		this._define("clock");
		this._define("__argc");
		this._define("__argv");
		this._define("__chrat");
		this._define("__exit");
		this._define("__fclose");
		this._define("__fgetc");
		this._define("__fopenr");
		this._define("__fopenw");
		this._define("__fputc");
		this._define("__ftoa");
		this._define("__stderr");
		this._define("__stdin");
		this._define("__stdout");
		this._define("__strlen");
		this._define("__strof");
		this._define("__trunc");
		super.visitProgram(node);
		this._endScope();
	}
	
	// Resolve a block statement node.
	visitBlockStmt(node) {
		this._beginScope(this._getClassType(), this._getFunctionType());
		super.visitBlockStmt(node);
		this._endScope();
	}
	
	// Resolve a class statement node.
	visitClassStmt(node) {
		var name = node.getName();
		this._declare(name, node.getSpan());
		this._define(name);
		var superclass = node.getSuperclass();
		
		if (superclass) {
			if (superclass.getName() == node.getName()) {
				this._logError("A class can't inherit from itself.", superclass);
			}
			
			this.visit(superclass);
			this._beginClassScope(ClassType.SUBCLASS);
		} else {
			this._beginClassScope(ClassType.CLASS);
		}
		
		for (var iter = node.getMethods().iter(); iter.hasNext();) {
			var method = iter.getNext();
			
			if (method.getName() == "init") {
				this._beginFunctionScope(FunctionType.INITIALIZER);
			} else {
				this._beginFunctionScope(FunctionType.METHOD);
			}
			
			this._resolveFunction(method);
			this._endScope();
		}
		
		this._endScope();
	}
	
	// Resolve a function statement node.
	visitFunctionStmt(node) {
		var name = node.getName();
		this._declare(name, node.getSpan());
		this._define(name);
		this._beginFunctionScope(FunctionType.FUNCTION);
		this._resolveFunction(node);
		this._endScope();
	}
	
	// Resolve a return statement node.
	visitReturnStmt(node) {
		var functionType = this._getFunctionType();
		
		if (functionType == FunctionType.NONE) {
			this._logError("Can't return from top-level code.", node);
		}
		
		var value = node.getValue();
		
		if (value) {
			if (functionType == FunctionType.INITIALIZER) {
				this._logError("Can't return a value from an initializer", value);
			}
			
			this.visit(value);
		}
	}
	
	// Resolve a var statement node.
	visitVarStmt(node) {
		var name = node.getName();
		this._declare(name, node.getSpan());
		var initializer = node.getInitializer();
		
		if (initializer) {
			this.visit(initializer);
		}
		
		this._define(name);
	}
	
	// Resolve a super expression node.
	visitSuperExpr(node) {
		var classType = this._getClassType();
		
		if (classType == ClassType.NONE) {
			this._logError("Can't use 'super' outside of a class.", node);
		} else if (classType != ClassType.SUBCLASS) {
			this._logError("Can't use 'super' in a class with no superclass.", node);
		}
	}
	
	// Resolve a this expression node.
	visitThisExpr(node) {
		if (this._getClassType() == ClassType.NONE) {
			this._logError("Can't use 'this' outside of a class.", node);
		}
	}
	
	// Resolve a variable expression node.
	visitVariableExpr(node) {
		var scope = this._scopes.peekBack();
		var name = node.getName();
		
		if (scope.hasDeclared(name) and !scope.hasDefined(name)) {
			this._logError("Can't read variable '" + name + "' in its own initializer.", node);
		} else if (!this._hasDefined(name)) {
			this._logError("Variable '" + name + "' is undefined in the current scope", node);
		}
	}
	
	// Get whether a name is defined in the current scope.
	_hasDefined(name) {
		for (var i = this._scopes.getLength() - 1; i >= 0; i = i - 1) {
			var scope = this._scopes.get(i);
			
			if (scope.hasDeclared(name)) {
				return scope.hasDefined(name);
			}
		}
		
		return false;
	}
	
	// Get the current scope's class type.
	_getClassType() {
		return this._scopes.peekBack().getClassType();
	}
	
	// Get the current scope's function type.
	_getFunctionType() {
		return this._scopes.peekBack().getFunctionType();
	}
	
	// Resolve a function statement node in the current scope.
	_resolveFunction(node) {
		var span = node.getSpan();
		
		for (var iter = node.getParams().iter(); iter.hasNext();) {
			var name = iter.getNext();
			this._declare(name, span);
			this._define(name);
		}
		
		super.visitFunctionStmt(node);
	}
	
	// Begin a new scope from its class type and function type.
	_beginScope(classType, functionType) {
		this._scopes.pushBack(Scope(classType, functionType));
	}
	
	// Begin a new class scope from its class type.
	_beginClassScope(classType) {
		this._beginScope(classType, this._getFunctionType());
	}
	
	// Begin a new function scope from its function type.
	_beginFunctionScope(functionType) {
		this._beginScope(this._getClassType(), functionType);
	}
	
	// End the current scope.
	_endScope() {
		this._scopes.popBack();
	}
	
	// Declare a name in the current scope at a span.
	_declare(name, span) {
		var scope = this._scopes.peekBack();
		
		if (scope.hasDeclared(name)) {
			this._log.logErrorAt(
					"Variable '" + name + "' is already declared in the current scope.", span);
		}
		
		scope.declare(name);
	}
	
	// Define a name in the current scope.
	_define(name) {
		this._scopes.peekBack().define(name);
	}
	
	// Log an error message at a node's span.
	_logError(message, node) {
		this._log.logErrorAt(message, node.getSpan());
	}
}
