// Test I/O extensions.

// Write a message to an output stream and return whether it was successful.
fun write(message, stream) {
	var length = __strlen(message);
	
	for (var i = 0; i < length; i = i + 1) {
		if(!__fputc(__chrat(message, i), stream)) {
			return false;
		}
	}
	
	return true;
}

// Print an error message.
fun error(message) {
	var stderr = __stderr();
	write(message, stderr);
	__fputc(10, stderr); // Line feed.
}

// Read a file as a string from its path.
fun slurp(path) {
	var stream = __fopenr(path);
	
	if (!stream) {
		error("Could not open '" + path + "' for reading.");
		return nil;
	}
	
	var byte = __fgetc(stream);
	var result = "";
	
	while (byte != nil) {
		if (byte == 0) {
			__fclose(stream);
			error("Read a null byte from '" + path + "'.");
			return nil;
		}
		
		result = result + __strof(byte);
		byte = __fgetc(stream);
	}
	
	if (!__fclose(stream)) {
		error("Could not close '" + stream + "' after reading.");
		return nil;
	}
	
	return result;
}

// Write a string to a file from its path and return whether it was successful.
fun unslurp(message, path) {
	var stream = __fopenw(path);
	
	if (!stream) {
		error("Could not open '" + path + "' for writing.");
		return false;
	}
	
	if (!write(message, stream)) {
		__fclose(stream);
		error("Could not write to '" + path + "'.");
		return false;
	}
	
	if (!__fclose(stream)) {
		error("Could not close '" + stream + "' after writing.");
		return false;
	}
	
	return true;
}

// Run a standard input loop and return an exit status code.
fun loop() {
	var stdin = __stdin();
	
	for (;;) {
		var byte = __fgetc(stdin);
		var result = "";
		
		while (byte != nil and byte != 10) {
			if (byte == 0) {
				error("Read a null byte from standard input.");
				return 1;
			}
			
			result = result + __strof(byte);
			byte = __fgetc(stdin);
		}
		
		if (result == "") {
			return 0;
		}
		
		print result;
	}
}

// Run the test script from arguments and return an exit status code.
fun main(argc, argv) {
	if (argc == 1) {
		return loop();
	} else if (argc == 2) {
		var message = slurp(argv(1));
		
		if (!message) {
			return 1;
		}
		
		write(message, __stdout());
		return 0;
	} else if (argc == 3) {
		var message = slurp(argv(1));
		
		if (!message) {
			return 1;
		}
		
		if (!unslurp(message, argv(2))) {
			return 1;
		}
		
		return 0;
	} else {
		error("Usage: cat.lox [source] [target]");
		return 1;
	}
}

{
	var status = main(__argc(), __argv);
	
	if (status != 0) {
		__exit(status);
	}
}
